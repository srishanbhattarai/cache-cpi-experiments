#!/usr/local/bin/python3

import subprocess
from terminaltables import AsciiTable

###########################################################################
#                           Constants                                     #
###########################################################################
CPI_BASE = 1

TRACE_FILES = ["Trace1.din", "Trace2.din", "Trace3.din"]

# Clock cycles for L1 hit.
L1_HIT_CYCLES = 1

# Clock cycles for L2 hit depending on L2 associativity.
L2_HIT_CYCLES_BY_ASSOC = {
        1: 4,
        2: 5,
        4: 6
        }

# Miss penalty for L1 and L2.
L1_MISS_CYCLES = 60
L2_MISS_CYCLES = 60

###########################################################################
#                           Utilties                                      #
###########################################################################
def create_all_dinero_cmds(raw_cmd):
    ''' 
    Given the raw dineroIV command, generates all required
    combinations of associativities and block sizes.

    Expects the raw_cmd to be properly formatted.
    '''
    associativities = [1, 2, 4]
    block_sizes = [32, 64]

    # Generate all combinations.
    commands = []
    for assoc in associativities:
        for bs in block_sizes:
            cmd = raw_cmd.format(
                    iassoc=assoc,
                    dassoc=assoc,
                    ibsize=bs,
                    dbsize=bs,
                    )

            commands.append({
                'cmd': cmd,
                'assoc': assoc,
                'bsize': bs
                })

    return commands

def show_trace_file_results(table_header, results, cpi_calc_func):
    '''
    Common function used by both simulations to print their output.
    '''
    out = [table_header]
    fastest = None
    for result in results:
        cpi_results = cpi_calc_func(result)

        table_entry = [
            '16K', # cache size
            result['associativity'],
            str(result['block_size']) + 'B',
            *cpi_results
        ]
        out.append(table_entry)

        # Save the lowest CPI yet.
        if fastest is None:
            fastest = table_entry
        else:
            index = len(table_entry) - 1 # last index holds CPI.
            if fastest[index] > table_entry[index]:
                fastest = table_entry
    
    table = AsciiTable(out)
    print(table.table)

    show_fastest_conf(fastest)

def run_simulation(tf, cmd, result_parser_func, expected_output_len):
    '''
    Run a trace file simulation.

    tf = trace_file
    cmd = fully formatted dineroIV command (output of create_all_dinero_cmds)
    result_parser_func = function to invoke with simulation results to extract data
    expected_output_len = expected length of simulation output, used for static assertions.
    '''

    # Run the command and capture output.
    output = run_sh_command(cmd['cmd'], tf)
    returncode, output, err = output
    output = output.splitlines()

    assert len(output) == expected_output_len, "The DineroIV output file was not of the right length."

    sim_results = result_parser_func(output)
    sim_results.update({
        'associativity': cmd['assoc'],
        'block_size': cmd['bsize'],
        })

    return sim_results

# Dump to stdout, but be pretty about it.
def printer():
    import pprint
    pp = pprint.PrettyPrinter(indent=4)

    def dump(v):
        pp.pprint(v)

    return dump

def cpi(miss_rate, miss_time):
    '''
    Formula for CPI.
    '''
    return miss_rate * miss_time

def amat(hit_time, miss_rate, miss_time):
    '''
    Formula for AMAT.
    '''
    return hit_time + miss_rate * miss_time

# Global print helper.
dump = printer()

def run_sh_command(cmd, file_to_pipe = None):
    '''
    Run an arbitrary shell command.
    USAGE: run_sh_command('ls -la')

    To get the output only:
    _, out, _ = run_sh_command('whoami')
    print(out.splitlines())
    '''
    argv = cmd.split(' ')

    # Input pipe
    input_bytes = ''
    if file_to_pipe is not None:
        with open(file_to_pipe) as f:
            b = f.read()
            input_bytes = b

    p = subprocess.run(
            argv,
            input=input_bytes,
            universal_newlines=True,
            capture_output=True
            )

    return (p.returncode, p.stdout, p.stderr)

###########################################################################
#                   Simulations Part One Start                            #
###########################################################################

def parse_l1_simulation(output):
    '''
    Given results of an L1 simulation, parses it to extract meaningful
    information.

    The format of the file generated by running the L1 simulation is 
    carefully parsed to populate the following dictionary.
    '''
    return {
            'icache': {
                'demand': output[36][23:29],
                'miss_rate': output[40][25:31] 
                },
            'dcache': {
                'demand': output[53][23:29],
                'miss_rate': output[57][25:31] 
                }
            } 

def run_l1_simulation(trace_file):
    '''
    Run the first part of the simulations for a given file. (L1 only)
    '''
    cmds = get_l1_commands()

    results = [] # List of all results for this simulation
    for cmd in cmds:
        result = run_simulation(trace_file, cmd, parse_l1_simulation, 68)
        results.append(result)

    return results

def get_l1_commands():
    ''' 
    Returns commands for running L1 only simulations while varying the 
    block size and associativity.
    '''
    # 16K fixed cache sizes
    base_cmd = 'dineroIV -informat d -l1-isize 16k -l1-dsize 16k -l1-iassoc {iassoc} -l1-dassoc {dassoc} -l1-ibsize {ibsize} -l1-dbsize {dbsize}'

    return create_all_dinero_cmds(base_cmd)

def total_cpi(result):
    '''
    Calculate Net CPI for I$ and D$.
    '''
    icache_miss_rate = float(result['icache']['miss_rate'])
    icache_demand = int(result['icache']['demand'])

    dcache_miss_rate = float(result['dcache']['miss_rate'])
    dcache_demand = int(result['dcache']['demand'])

    # fractions of instructions that are load store
    load_store_frac = float(dcache_demand) / float(icache_demand)

    cpi_icache = cpi(icache_miss_rate, L1_MISS_CYCLES)
    cpi_dcache = cpi(dcache_miss_rate, L1_MISS_CYCLES)
    net_cpi = CPI_BASE + cpi_icache + load_store_frac * cpi_dcache

    return [
        icache_demand,
        round(icache_miss_rate, 4),
        dcache_demand,
        round(dcache_miss_rate, 4),
        round(load_store_frac, 4),
        round(cpi_icache, 3),
        round(cpi_dcache, 3),
        round(net_cpi, 3)
    ]

def show_l1_trace_file_results(tf, results):
        print("\n")
        print("Trace File:", tf)
        table_header = [
            'Cache Size',
            'Associativity',
            'Block Size',
            'I$ demand',
            'I$ %miss',
            'D$ demand',
            'D$ %miss',
            '%Load/Store',
            'I$ CPI',
            'D$ CPI',
            'CPI'
        ]

        show_trace_file_results(table_header, results, total_cpi)

def show_fastest_conf(fastest):
    print("Fastest Configuration:")

    msg = '16K cache size, {assoc} associativity, {bs} BS, {cpi} CPI'

    # Cheap way to test if this had an L2 cache. The return value has
    # has more fields than an L1 simulation result table header.
    if len(fastest) == 13:
        msg = '16K L1 / 128K L2 cache size, {assoc} associativity, {bs} BS, {cpi} CPI'

    assoc = fastest[1]
    bs = fastest[2]
    cpi = fastest[len(fastest) - 1]

    print(msg.format(assoc=assoc, bs=bs, cpi=cpi))

def part_one():
    print("############ PART ONE SIMULATION START ###############")
    for tf in TRACE_FILES:
        results = run_l1_simulation(tf)
        show_l1_trace_file_results(tf, results)
    print("############ PART ONE SIMULATION END #################\n")

###########################################################################
#                   Simulations Part One End                              #
###########################################################################

###########################################################################
#                   Simulations Part Two Start                            #
###########################################################################

def parse_l2_simulation(output):
    '''
    Given results of an L1+L2 simulation, parses it to extract meaningful
    information.

    The format of the file generated by running simulation is 
    carefully parsed to populate the following dictionary.
    '''

    return {
            'l1_icache': {
                'demand': output[44][23:29],
                'miss_rate': output[48][25:31] 
                },
            'l1_dcache': {
                'demand': output[61][23:29],
                'miss_rate': output[65][25:31] 
                },
            'l2_ucache': {
                'demand': output[78][23:29],
                'miss_rate': output[82][25:31] 
                }
            } 

def total_cpi_l2(result):
    '''
    Calculate Net CPI for I$ and D$, when an L2 is present.
    '''
    icache_miss_rate = float(result['l1_icache']['miss_rate'])
    icache_demand = int(result['l1_icache']['demand'])

    dcache_miss_rate = float(result['l1_dcache']['miss_rate'])
    dcache_demand = int(result['l1_dcache']['demand'])

    # fractions of instructions that are load store
    load_store_frac = float(dcache_demand) / float(icache_demand)

    l2_miss_rate = round(float(result['l2_ucache']['miss_rate']), 4)
    amat_l2 = amat(
        L2_HIT_CYCLES_BY_ASSOC[result['associativity']],
        l2_miss_rate,
        L2_MISS_CYCLES
    )

    # Miss time of L1 = AMAT of L2.
    cpi_icache = cpi(icache_miss_rate, amat_l2)
    cpi_dcache = cpi(dcache_miss_rate, amat_l2)
    net_cpi = CPI_BASE + cpi_icache + load_store_frac * cpi_dcache

    return [
        icache_demand,
        round(icache_miss_rate, 4),
        dcache_demand,
        round(dcache_miss_rate, 4),
        round(load_store_frac, 4),
        result['l2_ucache']['demand'],
        l2_miss_rate,
        round(cpi_icache, 3),
        round(cpi_dcache, 3),
        round(net_cpi, 3)
    ]

def run_l2_simulation(tf):
    '''
    Run the second part of the simulation for a given file. (L1 + L2)
    '''
    cmds = get_l2_commands()    

    results = [] # List of all results for this simulation
    for cmd in cmds:
        result = run_simulation(tf, cmd, parse_l2_simulation, 93)
        results.append(result)

    return results

def get_l2_commands():
    '''
    Returns commands for running L1+L2 simulations while varying the 
    block size and associativity.
    ''' 

    # 16K L1 and 128K L2 fixed cache sizes
    base_cmd = 'dineroIV -informat d -l1-isize 16k -l1-dsize 16k -l1-iassoc {iassoc} -l1-dassoc {dassoc} -l1-ibsize {ibsize} -l1-dbsize {dbsize} -l2-usize 128k -l2-uassoc {iassoc} -l2-ubsize {dbsize}' 

    return create_all_dinero_cmds(base_cmd)

def show_l2_trace_file_results(tf, results):
    print("\n")
    print("Trace File:", tf)
    table_header = [
        'Cache Size',
        'Associativity',
        'Block Size',
        'L1 I$ demand',
        'L1 I$ %miss',
        'L1 D$ demand',
        'L1 D$ %miss',
        '%Load/Store',
        'L2 demand',
        'L2 %miss',
        'L1 I$ CPI',
        'L1 D$ CPI',
        'CPI'
    ]

    show_trace_file_results(table_header, results, total_cpi_l2)

def part_two():
    print("############ PART TWO SIMULATION START ###############")
    for tf in TRACE_FILES:
        results = run_l2_simulation(tf)
        show_l2_trace_file_results(tf, results)
    print("############ PART TWO SIMULATION END #################\n")

###########################################################################
#                   Simulations Part Two End                              #
###########################################################################

def main():
    part_one() # l1 only
    part_two() # l1 + l2

if __name__ == '__main__':
    main()
